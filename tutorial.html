
<!DOCTYPE html>
<!--
 Generated by Apache Maven Doxia at 2016-08-16
 Rendered using Reflow Maven Skin 1.1.1 (http://andriusvelykis.github.io/reflow-maven-skin)
-->
<html  xml:lang="en" lang="en">

	<head>
		<meta charset="UTF-8" />
		<title>vertx-futures</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<meta http-equiv="content-language" content="en" />

		<link href="http://netdna.bootstrapcdn.com/bootswatch/2.3.2/spruce/bootstrap.min.css" rel="stylesheet" />
		<link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-responsive.min.css" rel="stylesheet" />
		<link href="./css/bootswatch.css" rel="stylesheet" />
		<link href="./css/reflow-skin.css" rel="stylesheet" />

		<link href="http://yandex.st/highlightjs/7.5/styles/default.min.css" rel="stylesheet" />

		<link href="./css/lightbox.css" rel="stylesheet" />

		<link href="./css/site.css" rel="stylesheet" />
		<link href="./css/print.css" rel="stylesheet" media="print" />

		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
			<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->



	</head>

	<body class="page-tutorial project-vertx-futures" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

		<div class="navbar navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target="#top-nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<a class="brand" href="index.html">vertx-futures - work in progress</a>
					<div class="nav-collapse collapse" id="top-nav-collapse">
						<ul class="nav pull-right">
							<li ><a href="https://www.github.com/dazraf/vertx-futures" title="Source" class="externalLink">Source</a></li>
							<li class="dropdown active">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="index.html" title="Introduction">Introduction</a></li>
									<li class="active"><a href="" title="Tutorial and Examples">Tutorial and Examples</a></li>
									<li ><a href="api.html" title="API Documentation">API Documentation</a></li>
									<li ><a href="apidocs/index.html" title="JavaDocs" target="_blank">JavaDocs</a></li>
								</ul>
							</li>
						</ul>
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>

	<div class="container">

	<!-- Masthead
	================================================== -->

	<header>
		<div>
			<ul class="breadcrumb">
				<li class="projectVersion version-date">Version: 1.0-SNAPSHOT</li>
				<li class="divider">|</li>
				<li class="publishDate version-date">Last Published: 2016-08-16</li>
			</ul>
		</div>
	</header>

	<div class="main-body">
	<div class="row">
		<div class="span12">
			<div class="body-content">
<div class="page-header">
 <h1>Tutorials</h1>
</div> 
<div class="section"> 
 <h2 id="Useful_static_imports">Useful static imports</h2> 
 <p><tt>vertx-futures</tt> has a small number of classes for its entry-points. For legibility, it’s best to statically import these.</p> 
 <div class="source"> 
  <div class="source"> 
   <pre>  import static io.dazraf.vertx.tuple.Tuple.*; // for creating typesafe structures of results
  import static io.dazraf.vertx.futures.FutureChain.*; // for creating graphs of futures
  import static io.dazraf.vertx.futures.http.HttpFutures.*; // for working with vert.x http APIs
</pre> 
  </div> 
 </div> 
 <hr /> 
</div> 
<div class="section"> 
 <h2 id="Calling_a_webservice">Calling a webservice</h2> 
 <div class="source"> 
  <div class="source"> 
   <pre>  @Test
  public void simpleGetTest(TestContext context) {
    Async async = context.async();

    when(future(httpClient.get(&quot;/&quot;)).end())
      .onSuccess(HttpFutures::checkHttpSuccess)
      .then2(response -&gt; all(succeededFuture(response), bodyObject(response)))
      .onSuccess((response, body) -&gt; assertThat(context, body.containsKey(&quot;time&quot;), is(true)))
      .peekSuccess((response, body) -&gt; LOG.info(&quot;Response {} body checks out: {}&quot;, response.statusCode(), body.encode())) // 
      .onSuccess(async::complete) // if succeed to get to this point, complete the test
      .onFail((Runnable) context::fail); // if anything fails, fails the test
  }
</pre> 
  </div> 
 </div> 
 <p>Here, we write a unit test to call a Vert.x <a class="externalLink" href="http://vertx.io/docs/apidocs/io/vertx/core/http/HttpClient.html"><tt>HttpClient</tt></a> with request to <tt>GET /</tt>.</p> 
 <p>We convert the <a class="externalLink" href="http://vertx.io/docs/apidocs/io/vertx/core/http/HttpClientRequest.html"><tt>HttpClientRequest</tt></a> into a <a class="externalLink" href="http://vertx.io/docs/apidocs/io/vertx/core/Future.html"><tt>Future</tt></a> using the <a href="apiDocs/io/dazraf/vertx/futures/http/HttpFutures.html#future-io.vertx.core.http.HttpClientRequest-"><tt>future()</tt></a> factory method.</p> 
 <p>Once we have a <tt>Future</tt> we can start chaining its state to subsequent operations.</p> 
 <p>In this chase, if the http server responds, we:</p> 
 <ul> 
  <li>check for a successful status code</li> 
  <li>convert the body to a <a class="externalLink" href="http://vertx.io/docs/apidocs/io/vertx/core/json/JsonObject.html"><tt>JsonObject</tt></a> and return this together with the original response object using a <a href="apidocs/io/dazraf/vertx/futures/tuple/Tuple.html#all-T1-T2-"><tt>Tuple.all()</tt></a> factory method</li> 
  <li>check that the structure of the <tt>JsonObject</tt> is sound</li> 
  <li>if anywhere in the above code we have any untrapped errors, we fail the test.</li> 
 </ul> 
 <p><i>Please note</i> </p> 
 <p>Broadly speaking, we’ve only had to focus on the “happy” path. The handling and passing of failure conditions is carried out automatically by the library. </p> 
 <p>We use <a href="apidocs/io/dazraf/vertx/futures/tuple/Tuple.html#all-T1-T2-"><tt>Tuple.all()</tt></a> to create a return object that combines both the <tt>request</tt> and the <tt>body</tt>. This is to demonstrate that multiple results can be passed out from one stage to the next; all typesafe!</p> 
 <p>Also, the above example shows the use of <tt>onSuccess</tt> and <tt>peekSuccess</tt>. In the API these methods work in exactly the same way, except that:</p> 
 <ul> 
  <li><a href="apidocs/io/dazraf/vertx/futures/FutureChain.html#onSuccess-java.util.function.Consumer-"><tt>onSuccess</tt></a>, <a href="apidocs/io/dazraf/vertx/futures/FutureChain.html#onFail-java.util.function.Consumer-"><tt>onFail</tt></a>, <a href="apidocs/io/dazraf/vertx/futures/FutureChain.html#onComplete-java.util.function.Consumer-"><tt>onComplete</tt></a> etc will cause the flow to fail if the passed in handler function throws an exception</li> 
  <li><a href="apidocs/io/dazraf/vertx/futures/FutureChain.html#peekSuccess-java.util.function.Consumer-"><tt>peekSuccess</tt></a>, <a href="apidocs/io/dazraf/vertx/futures/FutureChain.html#peekFail-java.util.function.Consumer-"><tt>peekFail</tt></a>, <a href="apidocs/io/dazraf/vertx/futures/FutureChain.html#peekComplete-java.util.function.Consumer-"><tt>peekComplete</tt></a> etc will silently ignore any exception in the handler function (in fact, these are <tt>trace</tt>d to the logs, if enabled as such).</li> 
 </ul> 
 <hr /> 
</div> 
<div class="section"> 
 <h2 id="A_Galaxy_Far_Far_Away_">A Galaxy Far Far Away …</h2> 
 <p>We’re going to take the above and use it to access the awesome <a class="externalLink" href="http://swapi.co">Star Wars API</a>.</p> 
 <p>We’ll setup our test so that the <tt>HttpClient</tt> is configured to use <tt>http://swapi.co</tt> as the default host and port.</p> 
 <p>Then we’ll encapsulate what we discussed above as a handy function to retrieve the JsonObject from any GET request:</p> 
 <div class="source"> 
  <div class="source"> 
   <pre>  private Future&lt;JsonObject&gt; httpGetJsonObject(String resource) {
    return when(future(httpClient.get(resource)).end())
      .onSuccess(HttpFutures::checkHttpSuccess)
      .then(HttpFutures::bodyObject);
  }

</pre> 
  </div> 
 </div> 
 <p>Now, the StarWars API uses pagination, so we’ll need to recursively retrieve all pages:</p> 
 <div class="source"> 
  <div class="source"> 
   <pre>  private Future&lt;JsonObject&gt; httpGetJsonObject(String resource) {
    return when(future(httpClient.get(resource)).end())
      .onSuccess(HttpFutures::checkHttpSuccess)
      .then(HttpFutures::bodyObject)
      .then(result -&gt; {
        String next = result.getString(&quot;next&quot;);
        if (next != null) {
          return getRemainingPages(result, next);
        } else {
          return succeededFuture(result);
        }
      });
  }

  private Future&lt;JsonObject&gt; getRemainingPages(JsonObject result, String next) {
    final URI uri = URI.create(next);
    String path = uri.getPath() + &quot;?&quot; + uri.getQuery();
    return when(httpGetJsonObject(path)) //
      .map(remainder -&gt; {
        result.getJsonArray(&quot;results&quot;).addAll(remainder.getJsonArray(&quot;results&quot;));
        return result;
      });
  }
</pre> 
  </div> 
 </div> 
 <p>To show how that works, we’ll write a test to get a list of all Star Wars film titles.</p> 
 <div class="source"> 
  <div class="source"> 
   <pre>  @Test
  public void getFilms(TestContext testContext) {
    Async async = testContext.async();
    when(httpGetJsonObject(&quot;/api/films/&quot;))
      .map(jo -&gt; jo.getJsonArray(&quot;results&quot;).stream()
        .map(obj -&gt; ((JsonObject)obj))
        .map(obj -&gt; obj.getString(&quot;title&quot;))
        .collect(Collectors.toList()))
      .peekSuccess(list -&gt; list.forEach(LOG::info))
      .onSuccess(() -&gt; async.complete())
      .onFail(err -&gt; testContext.fail(err));
  }
</pre> 
  </div> 
 </div> 
 <p>… More tutorial to follow …</p> 
</div>
			</div>
		</div>
	</div>
	</div>

	</div><!-- /container -->

	<!-- Footer
	================================================== -->
	<footer class="well">
		<div class="container">
			<div class="row">
				<div class="span9 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">Documentation</li>
						<li >
							<a href="index.html" title="Introduction">Introduction</a>
						</li>
						<li class="active">
							<a href="#" title="Tutorial and Examples">Tutorial and Examples</a>
						</li>
						<li >
							<a href="api.html" title="API Documentation">API Documentation</a>
						</li>
						<li >
							<a href="apidocs/index.html" title="JavaDocs" target="_blank">JavaDocs</a>
						</li>
					</ul>
				</div>
				<div class="span3 bottom-description">
					<blockquote></blockquote>
				</div>
			</div>
		</div>
	</footer>

	<div class="container subfooter">
		<div class="row">
			<div class="span12">
				<p class="pull-right"><a href="#">Back to top</a></p>
				<p class="copyright">Copyright &copy;2016. All Rights Reserved.</p>
				<p><a href="http://github.com/andriusvelykis/reflow-maven-skin" title="Reflow Maven skin">Reflow Maven skin</a> by <a href="http://andrius.velykis.lt" target="_blank" title="Andrius Velykis">Andrius Velykis</a>.</p>
			</div>
		</div>
	</div>

	<!-- Le javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

	<script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
	<script src="./js/lightbox.min.js"></script>
	<script src="./js/reflow-scroll.js"></script>
	<script src="http://yandex.st/highlightjs/7.5/highlight.min.js"></script>

	<script src="./js/reflow-skin.js"></script>

	</body>
</html>
